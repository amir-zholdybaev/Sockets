import socket


listening_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
"""
    Происходит системный вызов socket() для создания сокета. Он передает ядру операционной системы параметры
    для создания сокета.

    Системный вызов - это способ обращения прикладной программы к ядру операционной системы для выполнения некоторой функции

    Ядро операционной системы решает, как именно создать сокет, в зависимости от типа протокола, домена и других факторов.

    Ядро операционной системы создает сокет. Некую сущность, для которой выделяет область в оперативной памяти, куда
    сохраняет параметры сокета, а также область в оперативной памяти, называемую буфером сокета. Буфер необходим для
    записи и считывания данных, то есть для обмена данными между сокетами.

    Далее этому сокету присваивается файловый дескриптор. Идентификатор.

    Системный вызов socket() возвращает этот дескриптор, теперь его можно использовать для работы с сокетом с помощью
    других системных вызовов, таких как bind(), listen(), connect(), send() и recv()

    У операционной системы есть таблица где сопоставлены файловые дескрипторы и адреса в оперативной памяти

    SOCK_STREAM и SOCK_DGRAM определяют тип сокета, но не протокол. То есть у тебя сокет или потоковый или datagram. А протокол может
    быть разным в зависимости от параметра domain.

    TCP и UDP это протоколы используемые для AF_INET \ AF_INET6 сокетов с типами SOCK_STREAM и SOCK_DGRAM соответственно.

    Если же например у тебя AF_UNIX сокет, то он тоже может иметь тип SOCK_STREAM или SOCK_DGRAM, но никакого TCP и UDP в Unix сокетах
    нет.

    Параметр - socket.AF_INET - указывает операционной системе, что сокет будет использовать семейство адресов IPv4
    Семейство адресов нужно указывать для того, чтобы операционная система знала, какой формат и диапазон адресов
    использовать для сокета

"""

listening_socket.bind(("127.0.0.1", 5000))

"""
    Происходит еще один системный вызов, который указывает операционной системе, что, если пришел запрос на подключение
    к ip “127.0.0.1” и порту 5000, то входящий запрос на подключение должен быть направлен к этому сокету.
    Это называется привязкой сокета к адресу

    Это необходимо для того, чтобы операционная система могла различать разные сокеты, которые работают с одним и тем же
    протоколом и доменом. Например, если у вас есть два серверных сокета, которые слушают TCP-соединения на локальном
    хосте, то вы должны привязать их к разным портам, чтобы избежать конфликта.
"""

listening_socket.listen(5)

"""
    Системный вызов listen() указывает операционной системе, что данный сокет готов принимать входящие
    соединения от других сокетов.

    Операционная система создает очередь для хранения запросов на соединение, которые приходят к данному сокету.
    Параметр 5, который передается в метод listen(), определяет максимальное количество запросов на соединение,
    которые могут быть помещены в очередь. Это называется размером бэклога (backlog).

    Если очередь заполнится, то операционная система будет отклонять или игнорировать новые запросы на соединение,
    пока не освободится место в очереди.

    В операционной системе будет запущен определенный цикл, который ждет входящие запросы на соединения с этим сокетом
    и в случае поступления запроса, он будет помещен в очередь
"""

socket_for_communication, addr = listening_socket.accept()

"""
    Системный вызов accept() извлекает первый запрос на соединение из очереди,
    которая была создана через вызов метода listen(), и устанавливает соединение с клиентским сокетом.

    Если в очереди нет запросов на подключение, то метод accept() будет ожидать появление хотябы одного,
    тем самым блокировать поток кода до тех пор, пока в очереди не опявиться хотябы один запрос на подключение

    Когда серверный сокет принимает соединение от клиента, он создает новый сокет для общения с этим клиентом

    Операционная система создает новый сокет для общения с подключающимся клиентским сокетом.
    То есть создает новый виртуальный файл, то есть выделяет еще одну область в оперативной памяти.

    Если запрос на подключение от клиентского сокета был изъят из очереди и принят, то клиентскому сокету
    отправляется сообщение о том, что соединение установлено. Это сообщение называется SYN-ACK (synchronize-acknowledge)
    и является частью трехстороннего рукопожатия (three-way handshake), которое используется для установления
    TCP-соединения между двумя сокетами. Клиентский сокет должен ответить на это сообщение своим ACK (acknowledge),
    чтобы подтвердить, что он готов к обмену данными с сокетом на стороне сервера. После этого соединение считается
    установленным и оба сокета могут отправлять и получать данные друг другу

    Системный вызов accept() возвращает дескриптор нового созданного сокета и адрес клиентского сокета, подключенного
    к новому сокету.

    Новый сокет можно использовать для отправки и получения данных от клиента с помощью методов send() и recv().

    Серверный сокет продолжает слушать входящие соединения и может принимать другие запросы на
    соединение, пока не достигнет предела бэклога.

    Новый сокет имеет другой дескриптор, отличающийся от дескриптора серверного сокета, но он не привязан к другому
    порту. Он использует тот же порт, что и серверный сокет, но для соединения с клиентским сокетом, который был
    к нему подключен

    Этот новый сокет имеет свой собственный дескриптор, но он наследует адрес и порт серверного сокета. Таким образом,
    наше серверное приложение может использовать один и тот же порт для прослушивания и общения с разными клиентами

    В новом сокете хранится информация о сокете клиента. Эта информация включает в себя адрес и порт клиента, а также
    состояние соединения. Получить эту информацию можно вызывая методы getpeername() и getsockopt()

    В новый сокет сохраняется адерс и порт серверного сокета, а также адрес и порт клиентского сокета. Эти четыре параметра
    вместе называются квадруплет.
    Когда операционная система получает пакет от клиентского сокета, она сравнивает его квадруплет с квадруплетами всех
    открытых сокетов на сервере и находит тот, который соответствует.
    Таким образом, операционная система может отличить разные соединения, которые используют один и тот же порт на сервере.
    Поэтому система знает какому сокету передать данные от клиентского сокета

    Серверный и новый сокеты используются одним и тем же процессом.
    Когда запускается наш python скрипт, в операционной системе создается процесс, который выполняет код скрипта.
    Этот процесс может создавать и использовать разные сокеты для общения с другими процессами, работающими на нашем
    или других компьютерах.
    Каждый сокет имеет свой дескриптор, который является уникальным идентификатором сокета внутри процесса.
    Процесс может обращаться к сокетам по их дескрипторам и выполнять различные операции с ними, такие как привязка,
    прослушивание, подключение, отправка и получение данных.
"""

data = socket_for_communication.recv(1024)

"""
    Системный вызов recv() запрашивает операционную систему, чтобы она прочитала данные из сокета,
    который был создан для общения с клиентом.

    Операционная система проверяет, есть ли данные в буфере сокета, полученные от клиента.
    Буфер сокета - это область в оперативной памяти, которая используется для временного хранения данных, передаваемых
    между сокетами.

    Если в буфере сокета есть данные, то операционная система копирует их в буфер приложения, который хранит данные,
    полученные от операционной системы. Буфер приложения - это область в оперативной памяти, которая используется для
    временного хранения данных, передаваемых между приложением и операционной системой.

    Размер буфера приложения указывается при вызове метода recv() - data = socket_for_communication.recv(1024)
    В данном примере под буфер приложения выделяется 1024 байт. Параметр 1024, который передается в метод recv(),
    определяет максимальное количество байтов, которые могут быть прочитаны из сокета за один раз. Это называется
    размером буфера приложения (application buffer size).

    Если в буфере сокета есть больше данных, чем может вместить буфер приложения, то операционная система не копирует
    все данные за один раз, а делит их на части. Каждый вызов recv() копирует одну часть данных из буфера сокета в буфер
    приложения и возвращает ее. Оставшиеся данные остаются в буфере сокета до тех пор, пока не будут прочитаны следующим
    вызовом recv() или не будут удалены при закрытии сокета.

    Это делается для того, чтобы избежать переполнения буфера приложения, которое может привести к потере данных или ошибкам.
    Это может сэкономить оперативную память. Если вы читаете большое количество данных из сокета, то вам может не хватить
    памяти для других операций или приложений.
    Также это позволяет контролировать скорость обмена данными между сокетами и адаптироваться к разным условиям сети.
    Это может улучшить производительность передачи данных, если вы используете неблокирующий режим работы с сокетом.
    В этом случае вы можете читать данные из сокета по мере их поступления, не дожидаясь, пока буфер сокета не заполнится
    полностью. Это может уменьшить задержку и перегрузку в сети.

    Операционная система возвращает количество скопированных байтов и очищает буфер сокета от этих данных. Если в буфере
    сокета было больше данных, чем может вместить буфер приложения, то операционная система копирует только часть данных
    и оставляет остальные в буфере сокета для следующего вызова recv().

    Если в буфере сокета нет данных, то поведение метода recv() зависит от того, какой режим работы с сокетом был установлен.
    Режим работы с сокетом - это параметр, который определяет, как приложение и операционная система должны реагировать на
    отсутствие или задержку данных в сокете.

    Если режим работы с сокетом - блокирующий (blocking), то метод recv() будет ждать появления данных в буфере сокета,
    тем самым блокируя поток кода до тех пор, пока не будут получены данные или не будет закрыто соединение.
    Это называется блокировкой на чтение (read blocking).

    Если режим работы с сокетом - неблокирующий (non-blocking), то метод recv() не будет ждать появления данных в буфере
    сокета, а вернет ошибку EWOULDBLOCK или EAGAIN и продолжит выполнение кода. Это называется неблокирующим чтением
    (non-blocking reading).

    Системный вызов recv() возвращает данные, прочитанные из сокета, в виде байтовой строки. Эту строку можно преобразовать
    в другой формат данных, например, в текстовую строку или JSON-объект, с помощью соответствующих функций.
"""

socket_for_communication.sendall(bytes(data))

"""
    sendall() запрашивает операционную систему, чтобы она отправила данные из приложения в сокет, который
    был создан для общения с клиентом. sendall это не системный вызов, это питонячья обертка над send().

    Данные из переменной data копируются в буфер приложения. Затем операционная система копирует данные из буфера приложения
    в буфер сокета и отправляет их в сеть, если сокет получателя готов к их принятию.

    Операционная система отправляет данные из буфера сокета в сеть, используя протокол TCP.

    Метод sendall() гарантирует, что все данные будут отправлены в сокет. Он продолжает вызывать системный вызов send()
    до тех пор, пока все данные не будут отправлены или не произойдет ошибка.

    Системный вызов sendall() не возвращает никаких данных. Он только отправляет данные в сокет и возвращает статус
    выполнения операции.

    Метод send() блокирует поток до тех пор, пока сокет получатель не будет готов к принятию данных и пока данные не будут
    отправлены.
    Метод sendall() может быть блокирующим в зависимости от того, какой режим работы с сокетом был установлен.
    Если режим работы с сокетом - блокирующий (blocking), то метод sendall() будет ждать, пока все данные не будут
    отправлены по сети в сокет клиента, блокируя поток кода до тех пор, пока не будут отправлены все данные
    или не будет закрыто соединение. Это называется блокировкой на запись (write blocking).

    sendall() будет блокировать выполнение кода, пока все данные не будут отправлены в сокет. Он продолжает вызывать
    системный вызов send() до тех пор, пока все данные не будут отправлены или не произойдет ошибка. Если произойдет
    ошибка, то метод sendall() вернет ее и прекратит выполнение.

    Основное отличие между методами send() и sendall() заключается в том, что метод send() может отправить только
    часть данных за один раз, тогда как метод sendall() гарантирует, что все данные будут отправлены в сокет.
"""
